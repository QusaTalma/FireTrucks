// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace Utils{
	public class MathUtils{
		/**
		 * Returns a negative number if B is left of A, positive if it is right
		 **/
		public static float AngleDir(Vector2 A, Vector2 B)
		{
			return -A.x * B.y + A.y * B.x;
		}

		public static float AngleDir(Vector3 fwd, Vector3 targetDir, Vector3 up)
			
		{
			
			Vector3 perp = Vector3.Cross(fwd, targetDir);
			
			float dir = Vector3.Dot(perp, up);
			
			
			
			if (dir > 0.0f) {
				
				return 1.0f;
				
			} else if (dir < 0.0f) {
				
				return -1.0f;
				
			} else {
				
				return 0.0f;
				
			}
			
		}

		public static Vector2 Abs(Vector2 vector) {
			for (int i = 0; i < 2; ++i) vector[i] = Mathf.Abs(vector[i]);
			return vector;
		}   
		
		public static Vector2 DividedBy(Vector2 vector, Vector2 divisor) {
			for (int i = 0; i < 2; ++i) vector[i] /= divisor[i];
			return vector;
		}
		
		public static Vector2 Max(Rect rect) {
			return new Vector2(rect.xMax, rect.yMax);
		}
		
		public static Vector2 IntersectionWithRayFromCenter(Rect rect, Vector2 pointOnRay) {
			Vector2 pointOnRay_local = pointOnRay - rect.center;
			Vector2 edgeToRayRatios = DividedBy(Max(rect) - rect.center, Abs(pointOnRay_local));
			return (edgeToRayRatios.x < edgeToRayRatios.y) ?
				new Vector2(pointOnRay_local.x > 0 ? rect.xMax : rect.xMin, 
				            pointOnRay_local.y * edgeToRayRatios.x + rect.center.y) :
					new Vector2(pointOnRay_local.x * edgeToRayRatios.y + rect.center.x, 
					            pointOnRay_local.y > 0 ? rect.yMax : rect.yMin);
		}
	}
}